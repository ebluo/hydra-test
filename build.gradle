apply plugin: 'wrapper'

buildscript {
  repositories {
    maven { url "https://plugins.gradle.org/m2" }
    jcenter()
  }
  dependencies {
    classpath 'com.github.jengelman.gradle.plugins:shadow:1.2.2'
  }
}

allprojects {
  // We want to see all test results.  This is equivalent to setting --continue
  // on the command line.
  gradle.startParameter.continueOnFailure = true

  repositories {
    jcenter()
    maven { url 'https://repo.spring.io/libs-release' }
  }

  gradle.taskGraph.whenReady( { graph ->
    tasks.withType(Tar).each { tar ->
      tar.compression = Compression.GZIP
      tar.extension = 'tar.gz'
    }
  })

  ext {
    scalaBinaryVersion = '2.10'
    scalaVersion = scalaBinaryVersion + '.6'
    springVersion = '3.2.12.RELEASE'
    log4jVersion = '1.2.17'
    slf4jVersion = '1.7.12'
    junitVersion = '4.11'
    antVersion = '1.8.4'
    pxfVersion = '2.5.1.0'
    osgiVersion = '6.0.0'
    jettyVersion = '8.1.14.v20131031'
    hadoopVersion = '2.4.1'
    hbaseVersion = '0.94.27'
    derbyVersion = '10.10.2.0'
    //hbaseVersion = '0.94.4-gemfire-r45047'
    //hadoopVersion = '2.2.0-gphd-3.1.0.0'
    //hadoopVersion = '2.4.1-gphd-3.2.0.0-54'

    // product and release properties
    PRODUCT_NAME = 'GemFireXD'
    PRODUCT_NAME_FULL = "Pivotal ${PRODUCT_NAME}"

    GEMFIRE_PRODUCT = 'Pivotal GemFire'
    GEMFIRE_VERSION = '7.5.Beta'

    PRODUCT_MAJOR = '2'
    PRODUCT_MINOR = '0'
    PRODUCT_MAINT = 'SNAPSHOT.1'
    PRODUCT_VERSION = "${PRODUCT_MAJOR}.${PRODUCT_MINOR}-${PRODUCT_MAINT}"
    PRODUCT_VENDOR = 'Pivotal Software, Inc.'
    COPYRIGHT = "Copyright 1997-2015, ${PRODUCT_VENDOR} All rights reserved."

    if (rootProject.name == 'hydra-test') {
      subprojectBase = ':'
      gitCmd = "git --git-dir=${rootDir}/.git --work-tree=${rootDir}"
    } else {
      subprojectBase = ':hydra-test:'
      gitCmd = "git --git-dir=${project(':hydra-test').projectDir}/.git --work-tree=${project(':hydra-test').projectDir}"
    }

    gitBranch = "${gitCmd} rev-parse --abbrev-ref HEAD".execute().text.trim()
    commitId = "${gitCmd} rev-parse HEAD".execute().text.trim()
    sourceDate = "${gitCmd} log -n 1 --format=%ai".execute().text.trim()

    osArch = System.getProperty('os.arch')
    osName = org.gradle.internal.os.OperatingSystem.current()
    osVersion = System.getProperty('os.version')
    buildDate = new Date().format('yyyy-MM-dd HH:mm:ss Z')
    buildNumber = new Date().format('MMddyy')
    jdkVersion = System.getProperty('java.version')
  }

  buildRoot = buildRoot.trim()
  def osDir = osName.getFamilyName().toLowerCase()
  if (!buildRoot.isEmpty()) {
    buildDir = new File(buildRoot, osDir + '/' +  project.path.replace(':', '/'))
  } else {
    buildDir = 'build-artifacts/' + osDir
  }

  ext {
    testResultsBase = "${rootProject.buildDir}/tests"
  }

  group = 'org.pivotal.gemfirexd'
  version = PRODUCT_VERSION

  apply plugin: 'java'
  apply plugin: 'maven'
  apply plugin: 'idea'
  apply plugin: 'eclipse'
}

def writeProperties(def parent, def name, def comment, def propsMap) {
  parent.exists() || parent.mkdirs()
  def writer = new File(parent, name).newWriter()
  def props = new Properties()
  propsMap.each { k, v -> props.setProperty(k, v.toString()) }
  try {
    props.store(writer, comment.toString())
    writer.flush()
  } finally {
    writer.close()
  }
}

def writeTestProperties(def parent, def name) {
  def availablePortFinder = AvailablePortFinder.createPrivate()
  writeProperties(new File(parent, name), 'gemfire.properties',
      'Autogenerated Gemfire properties', [
      'mcast-port': Integer.toString(availablePortFinder.nextAvailable),
      'log-level': 'config' ])
}

def getManifest(def symname, def imports, def exports, def otherAttrs) {
  def attrs = [
    "Manifest-Version"        : "1.0",
    "Title"                   : PRODUCT_NAME,
    "Bundle-Name"             : "${PRODUCT_NAME_FULL} ${PRODUCT_VERSION}",
    "Bundle-Version"          : PRODUCT_VERSION,
    "Bundle-Vendor"           : PRODUCT_VENDOR,
    "Bundle-SymbolicName"     : symname,
    "Bundle-ActivationPolicy" : "lazy",
    "Bundle-NativeCode"       : "com/sun/jna/win32-x86/jnidispatch.dll; processor=x86;osname=win32, com/sun/jna/win32-x86-64/jnidispatch.dll; processor=x86-64;osname=win32, com/sun/jna/w32ce-arm/jnidispatch.dll; processor=arm;osname=wince,  com/sun/jna/sunos-x86/libjnidispatch.so; processor=x86;osname=sunos, com/sun/jna/sunos-x86-64/libjnidispatch.so; processor=x86-64;osname=sunos, com/sun/jna/sunos-sparc/libjnidispatch.so; processor=sparc;osname=sunos, com/sun/jna/sunos-sparcv9/libjnidispatch.so; processor=sparcv9;osname=sunos,  com/sun/jna/aix-ppc/libjnidispatch.a; processor=ppc;osname=aix, com/sun/jna/aix-ppc64/libjnidispatch.a; processor=ppc64;osname=aix,  com/sun/jna/linux-ppc/libjnidispatch.so; processor=ppc;osname=linux, com/sun/jna/linux-ppc64/libjnidispatch.so; processor=ppc64;osname=linux, com/sun/jna/linux-x86/libjnidispatch.so; processor=x86;osname=linux, com/sun/jna/linux-x86-64/libjnidispatch.so; processor=x86-64;osname=linux, com/sun/jna/linux-arm/libjnidispatch.so; processor=arm;osname=linux, com/sun/jna/linux-ia64/libjnidispatch.so; processor=ia64;osname=linux,  com/sun/jna/freebsd-x86/libjnidispatch.so; processor=x86;osname=freebsd, com/sun/jna/freebsd-x86-64/libjnidispatch.so; processor=x86-64;osname=freebsd, com/sun/jna/openbsd-x86/libjnidispatch.so; processor=x86;osname=openbsd, com/sun/jna/openbsd-x86-64/libjnidispatch.so; processor=x86-64;osname=openbsd,  com/sun/jna/darwin/libjnidispatch.jnilib; osname=macosx;processor=x86;processor=x86-64;processor=ppc",
    "DynamicImport-Package"   : imports,
    "Export-Package"          : exports
  ]
  attrs.putAll(otherAttrs)
  return attrs
}

def generateCommonManifest(def pdir, def bdir) {
  def ddir = "${bdir}/resources/main/META-INF/"
  def fdir = new File(ddir)
  fdir.exists() || fdir.mkdirs()
  copy {
    from "${pdir}/.."
    into ddir
    include 'LICENSE*'
    include 'NOTICE*'
  }
}

def replaceRegex(def fileDir, def fileName, def regex, def replacement) {
  def tmpDir = "${buildDir}/tmp"
  def filePath = "${fileDir}/${fileName}"
  copy {
    from filePath
    into tmpDir
    filter { line ->
      line.replaceAll(regex, replacement)
    }
  }
  file("${tmpDir}/${fileName}").renameTo(file(filePath))
}

def getStackTrace(def t) {
  java.io.StringWriter sw = new java.io.StringWriter()
  java.io.PrintWriter pw = new java.io.PrintWriter(sw)
  org.codehaus.groovy.runtime.StackTraceUtils.sanitize(t).printStackTrace(pw)
  return sw.toString()
}

task cleanStoreJUnit << {
  def workingDir = "${testResultsBase}/junit"
  delete workingDir
  file(workingDir).mkdirs()
}

subprojects {
  // apply compiler options
  sourceCompatibility = 1.7
  targetCompatibility = 1.7

  compileJava.options.encoding = 'UTF-8'
  javadoc.options.charSet = 'UTF-8'

  configurations {
    provided {
      description 'a dependency that is provided externally at runtime'
      visible true
    }

    testOutput {
      extendsFrom testCompile
      description  'a dependency that exposes test artifacts'
    }
  }

  // Here we want to disable all transitive dependencies on external artifacts.  This
  // allows us to lock down library versions.  However, we want project dependencies to
  // be transitive such that the libraries of a dependent project are automatically included.
  configurations.all {
    dependencies.all { dep ->
      if (dep instanceof ModuleDependency && !(dep instanceof ProjectDependency)) {
        dep.transitive = false
      }
    }
    resolutionStrategy {
      // fail eagerly on version conflict (includes transitive dependencies)
      // e.g. multiple different versions of the same dependency (group and name are equal)
      failOnVersionConflict()
    }
  }

  eclipse {
    classpath {
      defaultOutputDir = file('build-eclipse')
      plusConfigurations += [ configurations.provided ]     
    }
    // Several files have UTF-8 encoding and Eclipse running on Windows
    // will have trouble unless we tell it to use UTF-8 encoding.
    // This setting needs to go into the core.resources.prefs file,
    // which the JDT script isn't set up to configure
    eclipseJdt << {
      File f = file('.settings/org.eclipse.core.resources.prefs')
      f.write('eclipse.preferences.version=1\n')
      f.append('encoding/<project>=utf-8')
    }
  }

  cleanEclipse << {
    delete '.settings/org.eclipse.core.resources.prefs'
  }

  idea {
    module {
      scopes.PROVIDED.plus += [ configurations.provided ]
    }
  }

  task jarTest (type: Jar, dependsOn: testClasses) {
    description 'Assembles a jar archive of test classes.'
    from sourceSets.test.output
    classifier 'test'
  }

  artifacts {
    testOutput jarTest
  }

  sourceSets {
    main.compileClasspath += configurations.provided
    main.runtimeClasspath -= configurations.provided
    test.compileClasspath += configurations.provided
    test.runtimeClasspath += configurations.provided
  }

  javadoc.classpath += configurations.provided

  dependencies {
    provided 'com.google.code.findbugs:annotations:3.0.0'
    compile "log4j:log4j:${log4jVersion}"
    compile "org.slf4j:slf4j-api:${slf4jVersion}"
    compile "org.slf4j:slf4j-log4j12:${slf4jVersion}"

    testCompile "junit:junit:${junitVersion}"
    testCompile 'org.hamcrest:hamcrest-core:1.1'
    testCompile 'org.hamcrest:hamcrest-library:1.1'
    testCompile 'org.jmock:jmock:2.5.1'
    testCompile 'org.jmock:jmock-legacy:2.5.1'
    testCompile 'edu.umd.cs.mtc:multithreadedtc:1.01'
    testRuntime 'cglib:cglib-nodep:2.1_3'
    testRuntime 'org.objenesis:objenesis:1.0'
  }

  test {
    //maxParallelForks = (2 * Runtime.getRuntime().availableProcessors())

    include '**/*Test.class'
    exclude '**/*DUnitTest.class'
    exclude '**/*DUnit.class'
    exclude '**/derbyTesting/**'
    useJUnit {
      excludeCategories 'com.gemstone.junit.IntegrationTest'
      excludeCategories 'com.gemstone.junit.DistributedTest'
    }

    workingDir = "${testResultsBase}/junit"
    delete workingDir
    file(workingDir).mkdirs()
    writeTestProperties(workingDir, '.')

    binResultsDir = file("${workingDir}/binary/${project.name}")
    reports.html.destination = file("${workingDir}/html/${project.name}")
    reports.junitXml.destination = file(workingDir)

    // run each test in its own vm to avoid interference issues if a test doesn't clean up
    // state
    //forkEvery 1
  }
  task integrationTest(type:Test) {
    maxParallelForks = (2 * Runtime.getRuntime().availableProcessors())

    include '**/*Test.class'
    exclude '**/*DUnitTest.class'
    exclude '**/*DUnit.class'
    useJUnit {
      includeCategories 'com.gemstone.junit.IntegrationTest'
      excludeCategories 'com.gemstone.junit.UnitTest'
      excludeCategories 'com.gemstone.junit.DistributedTest'
    }    

    workingDir = "${testResultsBase}/integration"
    delete workingDir
    file(workingDir).mkdirs()
    writeTestProperties(workingDir, '.')

    binResultsDir = file("${workingDir}/binary/${project.name}")
    reports.html.destination = file("${workingDir}/html/${project.name}")
    reports.junitXml.destination = file(workingDir)

    forkEvery 1
  }
  task distributedTest(type:Test) {
    maxParallelForks = Runtime.getRuntime().availableProcessors()

    include '**/*DUnitTest.class'
    include '**/*DUnit.class'

    workingDir = "${testResultsBase}/dunit"
    delete workingDir
    file(workingDir).mkdirs()
    writeTestProperties(workingDir, '.')

    binResultsDir = file("${workingDir}/binary/${project.name}")
    reports.html.destination = file("${workingDir}/html/${project.name}")
    reports.junitXml.destination = file(workingDir)

    //I'm hoping this might deal with SOME OOMEs I've seen
    forkEvery 30
  }

  // apply common test configuration
  gradle.taskGraph.whenReady( { graph ->
    tasks.withType(Test).each { test ->
      check.dependsOn test
      test.configure {
        onlyIf { ! Boolean.getBoolean('skip.tests') }

        minHeapSize '128m'
        maxHeapSize '1g'
        jvmArgs = ['-XX:+HeapDumpOnOutOfMemoryError', '-XX:MaxPermSize=256M', '-ea']
        maxParallelForks = 1

        testLogging.exceptionFormat = 'full'

        systemProperties 'gemfire.DEFAULT_MAX_OPLOG_SIZE' : '10',
          'gemfire.disallowMcastDefaults'  : 'true',
          'java.net.preferIPv4Stack'       : 'true',
          'jline.terminal'                 : 'scala.tools.jline.UnsupportedTerminal',
          'gemfiretest.sourceDir'          : "${projectDir}/src/test/resources"

      }
    }
  })

  test.dependsOn subprojectBase + 'cleanStoreJUnit'
  check.dependsOn integrationTest
  check.dependsOn distributedTest
}

test.dependsOn subprojects.collect { p -> p.getTasksByName('test', false).collect { it.path } }
check.dependsOn subprojects.collect { p -> p.getTasksByName('check', false).collect { it.path } }

task combineReports(type: TestReport) {
  description 'Combines the test reports.'
  destinationDir = file("${testResultsBase}/combined-reports")
}

gradle.taskGraph.whenReady({ graph ->
  tasks.getByName('combineReports').reportOn rootProject.subprojects.collect{ it.tasks.withType(Test) }.flatten()
})

task generateSources {
  dependsOn subprojectBase + 'gemfire-core:createVersionPropertiesFile'
}

def includeJar(def jarFile) {
  def jarName = jarFile.getName()
  return jarName.contains('jetty') || jarName.contains('spring') ||
    jarName.contains('hbase') || jarName.contains('pxf') ||
    jarName.contains('osgi') || jarName.contains('ant-') ||
    jarName.contains('jline')
}
